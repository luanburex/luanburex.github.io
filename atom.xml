<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Rex博客]]></title>
  <subtitle><![CDATA[拥有好奇心才懂得探索]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://luanburex.github.io/"/>
  <updated>2016-01-14T06:33:20.510Z</updated>
  <id>http://luanburex.github.io/</id>
  
  <author>
    <name><![CDATA[ReX Ren]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[maven使用svn更新代码]]></title>
    <link href="http://luanburex.github.io/2016/01/14/maven%E4%BD%BF%E7%94%A8svn%E6%9B%B4%E6%96%B0%E4%BB%A3%E7%A0%81/"/>
    <id>http://luanburex.github.io/2016/01/14/maven使用svn更新代码/</id>
    <published>2016-01-14T05:47:38.000Z</published>
    <updated>2016-01-14T06:33:20.510Z</updated>
    <content type="html"><![CDATA[<p>通过maven的<a href="http://maven.apache.org/scm/maven-scm-plugin/" target="_blank" rel="external">scm plugin</a>更新工程代码，甚至可以做一些简单的svn操作。如果在windows先下载<a href="http://sourceforge.net/projects/win32svn/files/1.8.14/Setup-Subversion-1.8.14.msi/download" target="_blank" rel="external">subvesion的windows版本</a></p>
<p>首先要在pom.xml文件中设置scm配置，主要是设置Svn地址，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;scm&#62;&#10;    &#60;connection&#62;scm:svn:http://somerepository.com/svn_repo/trunk&#60;/connection&#62;&#10;    &#60;developerConnection&#62;scm:svn:https://somerepository.com/svn_repo/trunk&#60;/developerConnection&#62;&#10;    &#60;url&#62;http://somerepository.com/view.cvs&#60;/url&#62;&#10;&#60;/scm&#62;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>然后配置scm插件，要在plugins里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;plugins&#62;&#10;      &#60;plugin&#62;&#10;        &#60;groupId&#62;org.apache.maven.plugins&#60;/groupId&#62;&#10;        &#60;artifactId&#62;maven-scm-plugin&#60;/artifactId&#62;&#10;        &#60;version&#62;1.9.4&#60;/version&#62;&#10;        &#60;configuration&#62;&#10;          &#60;goals&#62;install&#60;/goals&#62;&#10;        &#60;/configuration&#62;&#10;      &#60;/plugin&#62;&#10;    &#60;/plugins&#62;</span><br></pre></td></tr></table></figure></p>
<p>配置用户名密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;plugins&#62;&#10;     &#60;plugin&#62;&#10;       &#60;groupId&#62;org.apache.maven.plugins&#60;/groupId&#62;&#10;       &#60;artifactId&#62;maven-scm-plugin&#60;/artifactId&#62;&#10;       &#60;version&#62;1.9.4&#60;/version&#62;&#10;       &#60;configuration&#62;&#10;         &#60;username&#62;username&#60;/username&#62;&#10;         &#60;password&#62;password&#60;/password&#62;&#10;       &#60;/configuration&#62;&#10;     &#60;/plugin&#62;&#10;   &#60;/plugins&#62;</span><br></pre></td></tr></table></figure></p>
<p>然后，就是命令的执行，我一般是使用更新<code>mvn scm:update</code>具体的命令行，我这里引用官方文档里的内容：</p>
<p>scm:add - command to add file<br>scm:bootstrap - command to checkout and build a project<br>scm:branch - branch the project<br>scm:changelog - command to show the source code revisions<br>scm:check-local-modification - fail the build if there is any local modifications<br>scm:checkin - command for commiting changes<br>scm:checkout - command for getting the source code<br>scm:diff - command for showing the difference of the working copy with the remote one<br>scm:edit - command for starting edit on the working copy<br>scm:export - command to get a fresh exported copy<br>scm:list - command for get the list of project files<br>scm:remove - command to mark a set of files for deletion<br>scm:status - command for showing the scm status of the working copy<br>scm:tag - command for tagging a certain revision<br>scm:unedit - command to stop editing the working copy<br>scm:update - command for updating the working copy with the latest changes<br>scm:update-subprojects - command for updating all projects in a multi project build<br>scm:validate - validate the scm information in the pom</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>通过maven的<a href="http://maven.apache.org/scm/maven-scm-plugin/">scm plugin</a>更新工程代码，甚至可以做一些简单的svn操作。如果在windows先下载<a href="http://sourceforge.net/projects/win32svn/files/1.8.14/Setup-Subversion-1.8.14.msi/download">subvesion的windows版本</a></p>
<p>首先要在pom.xml文件中设置scm配置，主要是设置Svn地址，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;scm&#62;&#10;    &#60;connection&#62;scm:svn:http://somerepository.com/svn_repo/trunk&#60;/connection&#62;&#10;    &#60;developerConnection&#62;scm:svn:https://somerepository.com/svn_repo/trunk&#60;/developerConnection&#62;&#10;    &#60;url&#62;http://somerepository.com/view.cvs&#60;/url&#62;&#10;&#60;/scm&#62;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="java" scheme="http://luanburex.github.io/tags/java/"/>
    
      <category term="maven" scheme="http://luanburex.github.io/tags/maven/"/>
    
      <category term="安装部署" scheme="http://luanburex.github.io/tags/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/"/>
    
      <category term="maven" scheme="http://luanburex.github.io/categories/maven/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[配置Maven使用grunt]]></title>
    <link href="http://luanburex.github.io/2016/01/13/%E9%85%8D%E7%BD%AEMaven%E4%BD%BF%E7%94%A8grunt/"/>
    <id>http://luanburex.github.io/2016/01/13/配置Maven使用grunt/</id>
    <published>2016-01-13T06:30:46.000Z</published>
    <updated>2016-01-14T05:37:24.946Z</updated>
    <content type="html"><![CDATA[<p>毋庸置疑，前端工程使用grunt/gulp构建，更加的方便自然，而maven可以作为整个项目的管理，那么就有一个现实的问题，需要通过maven来操作grunt进行前端构建。这种构建应该有两种形式，一种是前后端分别的项目；前后台都在一个项目。虽然两种形式的maven结构不同，但是需要调用grunt这个是无法改变的。不过我们下面讲的主要是一个单独的前端项目，怎么用maven构建。<br><a id="more"></a></p>
<h2 id="u9996_u5148_u8981_u5B89_u88C5_u597Dgrunt_u5DE5_u7A0B"><a href="#u9996_u5148_u8981_u5B89_u88C5_u597Dgrunt_u5DE5_u7A0B" class="headerlink" title="首先要安装好grunt工程"></a>首先要安装好grunt工程</h2><p>这种前端工程的安装方法，具体参照grunt的教程，但是一般会有Gruntfile.js和package.json文件。</p>
<h2 id="u521B_u5EFApom_u6587_u4EF6_uFF0C_u4F7F_u7528Front_maven_u63D2_u4EF6"><a href="#u521B_u5EFApom_u6587_u4EF6_uFF0C_u4F7F_u7528Front_maven_u63D2_u4EF6" class="headerlink" title="创建pom文件，使用Front maven插件"></a>创建pom文件，使用Front maven插件</h2><p>使用<a href="http://mvnrepository.com/artifact/com.github.eirslett/frontend-maven-plugin" target="_blank" rel="external">fronted maven plugin</a>插件可以把node.js放入到你的工程里，并不需要安装即可执行。<br>在maven里的pom.xml文件中,首先添加插件的定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;plugin&#62;&#10;   &#60;groupId&#62;com.github.eirslett&#60;/groupId&#62;&#10;   &#60;artifactId&#62;frontend-maven-plugin&#60;/artifactId&#62;&#10;   &#60;version&#62;0.0.16&#60;/version&#62;&#10;   &#60;!-- executions go here --&#62;&#10;&#60;/plugin&#62;</span><br></pre></td></tr></table></figure></p>
<p>然后把安装node.js和npm的工具的执行，下载的目录会放到node目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> &#60;executions&#62;&#10;&#10;            &#60;execution&#62;&#10;                &#60;id&#62;install node and npm&#60;/id&#62;&#10;                &#60;goals&#62;&#10;                    &#60;goal&#62;install-node-and-npm&#60;/goal&#62;&#10;                &#60;/goals&#62;&#10;                &#60;configuration&#62;&#10;                    &#60;nodeVersion&#62;v0.12.6&#60;/nodeVersion&#62;&#10;                    &#60;npmVersion&#62;2.11.2&#60;/npmVersion&#62;&#10;                &#60;/configuration&#62;&#10;            &#60;/execution&#62;&#10;&#60;/executions&#62;</span><br></pre></td></tr></table></figure></p>
<p>下一步就是修改package.json文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#10;  &#34;name&#34;:&#34;frontend-tools&#34;,&#10;  &#34;version&#34;:&#34;0.0.1&#34;,&#10;  &#34;dependencies&#34;: &#123;&#10;    &#34;grunt&#34;: &#34;~0.4.5&#34;,&#10;    &#34;grunt-cli&#34;: &#34;~0.1.13&#34;,&#10;    &#34;grunt-contrib-jshint&#34;:&#34;~0.10.0&#34;&#10;  &#125;,&#10;  &#34;devDependencies&#34;: &#123;&#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来就是在pom文件中加入执行npm install 的部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;execution&#62;&#10;  &#60;id&#62;npm install&#60;/id&#62;&#10;  &#60;phase&#62;generate-resources&#60;/phase&#62;&#10;  &#60;goals&#62;&#10;    &#60;goal&#62;npm&#60;/goal&#62;&#10;  &#60;/goals&#62;&#10;  &#60;configuration&#62;&#10;    &#60;arguments&#62;install&#60;/arguments&#62;&#10;  &#60;/configuration&#62;&#10;&#60;/execution&#62;</span><br></pre></td></tr></table></figure></p>
<p>然后就到了重点了，执行grunt的构建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;execution&#62;&#10;    &#60;id&#62;grunt build&#60;/id&#62;&#10;    &#60;goals&#62;&#10;        &#60;goal&#62;grunt&#60;/goal&#62;&#10;    &#60;/goals&#62;&#10;    &#60;configuration&#62;&#10;        &#60;arguments&#62;build --no-color&#60;/arguments&#62;&#10;    &#60;/configuration&#62;&#10;&#60;/execution&#62;</span><br></pre></td></tr></table></figure></p>
<p>最后好好修改Gruntfile.js文件，根据自己的需求就构建工程，使用命令<code>mvn package</code></p>
<h2 id="u5B8C_u6210_u7684_u4F8B_u5B50"><a href="#u5B8C_u6210_u7684_u4F8B_u5B50" class="headerlink" title="完成的例子"></a>完成的例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&#62;&#10;&#60;project xmlns=&#34;http://maven.apache.org/POM/4.0.0&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:schemaLocation=&#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&#34;&#62;&#10;    &#60;modelVersion&#62;4.0.0&#60;/modelVersion&#62;&#10;&#10;    &#60;groupId&#62;com.asiainfo&#60;/groupId&#62;&#10;    &#60;artifactId&#62;aiga-web&#60;/artifactId&#62;&#10;    &#60;version&#62;1.0.0&#60;/version&#62;&#10;    &#60;packaging&#62;pom&#60;/packaging&#62;&#10;&#10;&#10;    &#60;build&#62;&#10;        &#60;plugins&#62;&#10;            &#60;plugin&#62;&#10;                &#60;groupId&#62;com.github.eirslett&#60;/groupId&#62;&#10;                &#60;artifactId&#62;frontend-maven-plugin&#60;/artifactId&#62;&#10;                &#60;!-- NB! Set &#60;version&#62; to the latest released version of frontend-maven-plugin, like in README.md --&#62;&#10;                &#60;version&#62;0.0.26&#60;/version&#62;&#10;&#10;               &#60;executions&#62;&#10;&#10;                    &#60;execution&#62;&#10;                        &#60;id&#62;install node and npm&#60;/id&#62;&#10;                        &#60;goals&#62;&#10;                            &#60;goal&#62;install-node-and-npm&#60;/goal&#62;&#10;                        &#60;/goals&#62;&#10;                        &#60;configuration&#62;&#10;                            &#60;nodeVersion&#62;v0.12.6&#60;/nodeVersion&#62;&#10;                            &#60;npmVersion&#62;2.11.2&#60;/npmVersion&#62;&#10;                        &#60;/configuration&#62;&#10;                    &#60;/execution&#62;&#10;&#10;                     &#60;execution&#62;&#10;                        &#60;id&#62;npm install&#60;/id&#62;&#10;                        &#60;goals&#62;&#10;                            &#60;goal&#62;npm&#60;/goal&#62;&#10;                        &#60;/goals&#62;&#10;                        &#60;!-- Optional configuration which provides for running any npm command --&#62;&#10;                        &#60;configuration&#62;&#10;                            &#60;arguments&#62;install&#60;/arguments&#62;&#10;                        &#60;/configuration&#62;&#10;                    &#60;/execution&#62;&#10;&#10;                    &#60;execution&#62;&#10;                        &#60;id&#62;grunt build&#60;/id&#62;&#10;                        &#60;goals&#62;&#10;                            &#60;goal&#62;grunt&#60;/goal&#62;&#10;                        &#60;/goals&#62;&#10;                        &#60;configuration&#62;&#10;                            &#60;arguments&#62;build --no-color&#60;/arguments&#62;&#10;                        &#60;/configuration&#62;&#10;                    &#60;/execution&#62;&#10;&#10;&#10;            &#9;&#60;/executions&#62;&#10;            &#60;/plugin&#62;&#10;        &#60;/plugins&#62;&#10;    &#60;/build&#62;&#10;&#10;&#60;/project&#62;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>毋庸置疑，前端工程使用grunt/gulp构建，更加的方便自然，而maven可以作为整个项目的管理，那么就有一个现实的问题，需要通过maven来操作grunt进行前端构建。这种构建应该有两种形式，一种是前后端分别的项目；前后台都在一个项目。虽然两种形式的maven结构不同，但是需要调用grunt这个是无法改变的。不过我们下面讲的主要是一个单独的前端项目，怎么用maven构建。<br>]]>
    
    </summary>
    
      <category term="java" scheme="http://luanburex.github.io/tags/java/"/>
    
      <category term="maven" scheme="http://luanburex.github.io/tags/maven/"/>
    
      <category term="安装部署" scheme="http://luanburex.github.io/tags/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/"/>
    
      <category term="maven" scheme="http://luanburex.github.io/categories/maven/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自动化测试的思考（二）分层测试]]></title>
    <link href="http://luanburex.github.io/2016/01/12/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%9A%84%E6%80%9D%E8%80%83%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%86%E5%B1%82%E6%B5%8B%E8%AF%95/"/>
    <id>http://luanburex.github.io/2016/01/12/自动化测试的思考（二）分层测试/</id>
    <published>2016-01-12T09:18:22.000Z</published>
    <updated>2016-01-12T09:22:05.346Z</updated>
    <content type="html"><![CDATA[<p>由于多种原因吧，自动化测试刚开始发展，都想去做手工测试代替，都想做黑盒的覆盖测试。结果，自动化测试维护成本过高，稳定性也不好，但是执行效率，回归起来又不错。越来越多的人在思考如何更好的做自动化测试。尤其是在敏捷开发盛行的年代，自动化测试已经成了软件开发测试过程中，重要的组成部分，那么到底怎么做自动化测试收效最高呢。目前较为流行的方式–分层测试。<br>我比较推荐分层测试的金字塔说法：分层测试就是构建高效的测试金字塔，不同层次的测试可以用尽量低的成本防御不同类型的风险。<br>说法慢抽象的，先来看个实例图，再做慢慢解释：<br><img src="http://martinfowler.com/bliki/images/testPyramid/pyramid.png" alt="测试金子塔"><br><a id="more"></a><br>上面我们先看到了金字塔了，然后我以比较常见的web项目做例子来解释分层测试。诚如上面说的如果我们单纯做黑盒的自动化测试，其实就是在UI这个层次上，不断开发维护脚本，结果可能带来的风险就是人员的无限投入，却很难得到比较好的测试效果。而这个金子塔的意思就是将应用，分成不同层次的自动化测试，比方说UI就是通过界面进行端对端测试，一般是黑盒测试；service一般针对接口，服务，比方说如果你用REST方式构建web的话，那么可以对REST接口进行测试，还有比方说直接对HTTP接口进行测试，对webservice接口进行测试；而Unit这个包含的比较多了，简单的说在web应用的dao，service，controller，model这些可以写类似junit的单元测试，javascript，css也可以做前段的单元测试。这这个金子塔就说的，根据层次划分，不同层次的测试量不同， 越是在塔尖的，测试开发维护都比较复杂，那么测试的量就越小，而下层的单元测试则可进行比较高的覆盖测试。<br>简单的说，分层自动化测试，就是把我们单一看着UI的功能自动化测试，将自动化测试扩展到不同的软件层次上，进行测试。<br>这种测试方式，相比于传统的自动化测试，会有几个改变：</p>
<ul>
<li>将开发拉入测试：其实测试工作也是开发一个很重要的工作内容，传统的开发测试分的很细的方式，不利于分层测试，像单元测试，还是需要开发多多投入。</li>
<li>将测试引入开发：分层的测试，需要对被测系统的开发结构有认识，至少你要知道你覆盖了多少了吧，甚至开发大致怎么实现的，不然UI前面对那些接口也不知道那很难评估测试结果的。</li>
<li>最好跟持续集成配合使用：重复利用自动化测试的执行成本低的效率，在工程集成完毕前后，更加自动地执行测试，及时的反馈测试结果，从而更好地提高测试效率。</li>
<li>使用Mock来实现分层测试，因为是分层那么就可能有隔离一些模块或者外系统，那么就可以用Mock来模拟这些隔离的模块，进行测试。</li>
<li>需要合理的评估测试覆盖，不同层次的测试程度都需要合理的评估，这个范围的控制是保证分层测试测试质量的最核心的规划，这个才是成功关键。</li>
</ul>
<p>综上所述，分层自动化测试是追求覆盖的传统自动化测试的一种修正，充分利用自动化测试的优点，尽量规避自动化测试的缺点。当然分层测试也有些要注意的问题：</p>
<ul>
<li>测试重复：分层可能对测试是重复的，在上层测过了，下层还继续测。从测试角度上说是重复测试，但是从整个流程看测试的话，不同层次的测试，属于过程的不同阶段，比方说单元测试，可以在编译后进行测试，在集成前就可以发现问题，而UI的自动化测试则更加滞后一点，功能不同效果不同，测试的重复还是可以忍受的。</li>
<li>测试遗漏：这个就很需要对测试覆盖的规划能力，而且这里要说明的一点，自动化测试不能或者很难做到全覆盖测试。手工测试还是不能放下的，而手工做到全覆盖是有必要的。</li>
<li>测试复杂度，分层测试需要工具比较多，人员能力比较强，要控制那么多工具进行测试，还要对业务，甚至开发有了解，还要开发人员参与进来，投入也不小。</li>
</ul>
<p>不管分层测试有多少难度，他是目前解决自动化测试开发维护的一个比较好的方案。如果要大规模使用自动化测试，我想分层的思想应该是不容忽视的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>由于多种原因吧，自动化测试刚开始发展，都想去做手工测试代替，都想做黑盒的覆盖测试。结果，自动化测试维护成本过高，稳定性也不好，但是执行效率，回归起来又不错。越来越多的人在思考如何更好的做自动化测试。尤其是在敏捷开发盛行的年代，自动化测试已经成了软件开发测试过程中，重要的组成部分，那么到底怎么做自动化测试收效最高呢。目前较为流行的方式–分层测试。<br>我比较推荐分层测试的金字塔说法：分层测试就是构建高效的测试金字塔，不同层次的测试可以用尽量低的成本防御不同类型的风险。<br>说法慢抽象的，先来看个实例图，再做慢慢解释：<br><img src="http://martinfowler.com/bliki/images/testPyramid/pyramid.png" alt="测试金子塔"><br>]]>
    
    </summary>
    
      <category term="automation" scheme="http://luanburex.github.io/tags/automation/"/>
    
      <category term="自动化测试" scheme="http://luanburex.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自动化测试的思考（一）]]></title>
    <link href="http://luanburex.github.io/2016/01/12/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%9A%84%E6%80%9D%E8%80%83%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://luanburex.github.io/2016/01/12/自动化测试的思考（一）/</id>
    <published>2016-01-12T09:15:45.000Z</published>
    <updated>2016-01-12T09:22:02.318Z</updated>
    <content type="html"><![CDATA[<h2 id="u81EA_u52A8_u5316_u6D4B_u8BD5_u7684_u5F00_u59CB"><a href="#u81EA_u52A8_u5316_u6D4B_u8BD5_u7684_u5F00_u59CB" class="headerlink" title="自动化测试的开始"></a>自动化测试的开始</h2><p>自动化测试，从一个大家陌生的概念，到现在越来越多的人在关注使用自动化测试。似乎自动化测试已经成了一个“高级”。但是其实很多人对自动化测试本身有很多误解，自动化测试不是银弹，不是瑞士军刀。自动化测试并不能代替测试本身。很多领导或者客户了解到自动化测试，就都会有用自动化测试覆盖测试的冲动。在这种冲动下，投入大量的人力财力，经常是无功而返的。自动化测试到底怎么了？<br><a id="more"></a></p>
<h2 id="u81EA_u52A8_u5316_u6D4B_u8BD5_u5E76_u6CA1_u6709_u60F3_u8C61_u7684_u90A3_u4E48_u5B8C_u7F8E"><a href="#u81EA_u52A8_u5316_u6D4B_u8BD5_u5E76_u6CA1_u6709_u60F3_u8C61_u7684_u90A3_u4E48_u5B8C_u7F8E" class="headerlink" title="自动化测试并没有想象的那么完美"></a>自动化测试并没有想象的那么完美</h2><p>自动化测试到底都有哪些问题？我们为什么会经常感觉做不下去了？为什么投入那么多，效果总是那么一点点。<br>自动化测试本身有自动测试自己的问题，随着大量投入地去做自动化测试，这些问题会越来越明显，比方说：</p>
<ul>
<li>编写维护自动化测试脚本成本太高了</li>
<li>天天在跑自动化测试，发现的缺陷数量怎么就那么少</li>
<li>自动化测试为什么就没有节约人力成本</li>
<li>自动化测试为什么就你们几个能用，那么多手工测试人员就不能用起来吗？<br>这些问题，其实本身不是自动化测试的问题，而是把自动化测试本身放错了位置。就像开篇说的，自动化测试其实不是这样的。</li>
</ul>
<h2 id="u6211_u4EEC_u62FF_u81EA_u52A8_u5316_u6D4B_u8BD5_u600E_u4E48_u529E"><a href="#u6211_u4EEC_u62FF_u81EA_u52A8_u5316_u6D4B_u8BD5_u600E_u4E48_u529E" class="headerlink" title="我们拿自动化测试怎么办"></a>我们拿自动化测试怎么办</h2><p>自动化测试一般都是需要编写脚本，通过脚本的执行来达到测试的目的，一般被测系统稳定的话，那么脚本是不需要怎么维护的，反之的话，就比较恐怖了。所以要进行自动化测试，就需要下工夫去开发维护脚本，而且工作量不小。由于他有这种特性，所以自动化测试，尤其是针对业务的功能测试中，最好不要去拼命地覆盖全业务，覆盖所有案例，而且抓住重点核心业务进行回归测试。这样可以减少开发维护工作量，还能尽量保证重点业务的测试质量，测试性价比是最高的。<br><strong>原则1: 针对重点业务，进行回归的自动化测试</strong><br>另外，尽量针对较为稳定的业务，或者较为稳定的测试方式进行自动化测试，这样人力的投入主要集中的初期脚本的编写，而之后由于较为稳定，那么脚本的维护工作量也不会太大。当然，这种投入不是越早越好，很多项目经理都觉得自动化测试及早投入，这样我们在项目研发中就可以及早用，及早的享受到自动化测试带来的便利。其实自动化测试，一般要做环境比较稳定的情况再投入开发，这样可以减少维护的成本，另外对于不稳定的环境，执行自动化测试也没有太好的效果，经常跑出的脚本一堆问题，分析来半天其实就是不能用，这样测试的意义就不大了。<br><strong>原则2：针对稳定的业务（或接口），在环境比较稳定的情况，前期投入脚本开发，有利于减少后期维护成本</strong><br>还有很多自动化测试，几乎每天都在跑，老是发现脚本错误，怎么就没有真正的缺陷呢，出缺陷的概率这么多，就盲目地增加校验点，结果还是一样。其实不用为了发现不了缺陷而烦恼，自动化一般都是保证主要功能完整可用，这些是他的核心价值，而不是发现多少缺陷。<br><strong>原则3：自动化测试主要是为了保证主要功能完整可用，而不是为了多发现缺陷</strong><br>当然，还有些人，做自动化就是为了节约手工测试人员的人力成本，做着做着，发现做了那么长时间自动化测试，为什么人力成本没有减少。不减少我为什么做自动化测试啊？这也是一个误区，自动化测试并不能减少测试的人力成本，而是为了加快测试反馈，提升测试质量。我建议自动化测试可以跟自动化部署工具绑定，在每日构建的时候，自动化执行，可以更早的发现产品的问题，自动地反馈开发人员，从而提升开发修复缺陷的效率。<br><strong>原则4：自动化测试并不能减少测试的人力成本，而是为了加快测试反馈，提升测试质量</strong><br>还有一个问题，这个问题在初期开始做自动化测试的人，会比较容易走上的误区—-录制回放最好了。其实录制回放，并不好，录制的脚本很多时候是不能直接使用，而且业务或者系统发生变化，很有可能很难修改脚本需要重新录制恢复，这样的工作量也不小。而且还有很多人，自动化测试脚本应该跟业务能挂钩起来，让人一目了然我自动化测试脚本都做了些什么，脚本最好能做到<em>“可视化”</em>。其实这些看似的方便，都给脚本维护带来很多困难，业务和系统是在变化的，脚本是要不断维护，可视化和录制回放其实并不能提升效率，反而是为脚本维护增加工作量。建议如果有能力的话，对脚本本身进行管理即可，编写脚本不用录制回放，使用一些辅助工具，或者设计一些框架，编写脚本会更好。<br><strong>原则5：不要对录制回放抱有幻想了，可视化也不是一个好的想法</strong><br>最后一个问题，有很多人任务自动化测试执行这么方便，是否手工测试人员可以进行自动化测试啊？可以吗？很多人持不同观点，有的人任务测试其实要成为开发测试，有开发能力，去写自动化测试脚本；还有的人，觉得测试和自动化测试要分开，两个团队管理；还有的人任务，测试执行，测试数据编写等可以让手工人员参与。其实我觉得这都不是最好的想法。真正应该参与自动化测试的应该是开发。<br><strong>原则6:开发参与自动化测试，让开发和测试融合在一起</strong></p>
<h2 id="u6700_u4F73_u5B9E_u8DF5"><a href="#u6700_u4F73_u5B9E_u8DF5" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>说了这么多芝麻绿豆的，原则也好想法也好，是否有一套方法来支撑整个自动化测试呢，我想简单的说，我比较支持现在比较流行的说法分层测试。利用适宜的测试框架，按照分层测试的范围理论，结合较好的CI工具整合自动化测试。具体的做法我想在下面的章节一一解释说清。**</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u81EA_u52A8_u5316_u6D4B_u8BD5_u7684_u5F00_u59CB"><a href="#u81EA_u52A8_u5316_u6D4B_u8BD5_u7684_u5F00_u59CB" class="headerlink" title="自动化测试的开始"></a>自动化测试的开始</h2><p>自动化测试，从一个大家陌生的概念，到现在越来越多的人在关注使用自动化测试。似乎自动化测试已经成了一个“高级”。但是其实很多人对自动化测试本身有很多误解，自动化测试不是银弹，不是瑞士军刀。自动化测试并不能代替测试本身。很多领导或者客户了解到自动化测试，就都会有用自动化测试覆盖测试的冲动。在这种冲动下，投入大量的人力财力，经常是无功而返的。自动化测试到底怎么了？<br>]]>
    
    </summary>
    
      <category term="automation" scheme="http://luanburex.github.io/tags/automation/"/>
    
      <category term="自动化测试" scheme="http://luanburex.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[maven入门（二）创建一个maven工程]]></title>
    <link href="http://luanburex.github.io/2016/01/12/maven%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAmaven%E5%B7%A5%E7%A8%8B/"/>
    <id>http://luanburex.github.io/2016/01/12/maven入门（二）创建一个maven工程/</id>
    <published>2016-01-12T08:33:43.000Z</published>
    <updated>2016-01-12T09:08:03.981Z</updated>
    <content type="html"><![CDATA[<p>在这篇文章里，主要创建第一个maven工程，就是根据我们之前学到的基础信息，完成一个简单的实践。目标建立一个java工程，可以写java代码，然后打包成jar包。</p>
<h2 id="u5B89_u88C5Maven"><a href="#u5B89_u88C5Maven" class="headerlink" title="安装Maven"></a>安装Maven</h2><p>第一篇安装已经有相关的说明，请参照</p>
<a id="more"></a>
<h2 id="u521B_u5EFA_u5DE5_u7A0B"><a href="#u521B_u5EFA_u5DE5_u7A0B" class="headerlink" title="创建工程"></a>创建工程</h2><p>创建工程有两种方式，使用mvn的框架，比方说创建一个web工程可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:create -DgroupId=com.learn -DartifactId=LearnNew -DarchetypeArtifactId=maven-archetype-webapp</span><br></pre></td></tr></table></figure></p>
<p>第二种方式，就是自己建立目录结构，自己创建pom.xml文件</p>
<h3 id="u521B_u5EFApom_u6587_u4EF6"><a href="#u521B_u5EFApom_u6587_u4EF6" class="headerlink" title="创建pom文件"></a>创建pom文件</h3><p>创建pom.xml文件，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;project xmlns=&#34;http://maven.apache.org/POM/4.0.0&#34;&#10;         xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;&#10;         xsi:schemaLocation=&#34;http://maven.apache.org/POM/4.0.0&#10;                      http://maven.apache.org/xsd/maven-4.0.0.xsd&#34;&#62;&#10;    &#60;modelVersion&#62;4.0.0&#60;/modelVersion&#62;&#10;&#10;&#10;    &#60;groupId&#62;com.jenkov&#60;/groupId&#62;&#10;&#10;    &#60;artifactId&#62;hello-world&#60;/artifactId&#62;&#10;&#10;    &#60;version&#62;1.0.0&#60;/version&#62;&#10;&#10;&#60;/project&#62;</span><br></pre></td></tr></table></figure></p>
<p>这是一个最小内容的pom.xml文件：<br>groupId用自己的组织名称，并不一定要使用包名。<br>artifactId用项目的名称，生成jar包会默认使用这个名称<br>version版本号，可以从1.0.0开始起步</p>
<h3 id="u6D4B_u8BD5pom_u6587_u4EF6"><a href="#u6D4B_u8BD5pom_u6587_u4EF6" class="headerlink" title="测试pom文件"></a>测试pom文件</h3><p>你可以执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean</span><br></pre></td></tr></table></figure></p>
<p>该命令会清理项目中生成的各种临时文件，如果命令执行成功，那么结果大致如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\data\projects\my-first-maven-project&#62;mvn clean&#10;[INFO] Scanning for projects...&#10;[INFO]&#10;[INFO] ------------------------------------------------------------------------&#10;[INFO] Building hello-world 1.0.0&#10;[INFO] ------------------------------------------------------------------------&#10;[INFO]&#10;[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ hello-world ---&#10;[INFO] ------------------------------------------------------------------------&#10;[INFO] BUILD SUCCESS&#10;[INFO] ------------------------------------------------------------------------&#10;[INFO] Total time: 0.873 s&#10;[INFO] Finished at: 2015-07-05T14:57:00+02:00&#10;[INFO] Final Memory: 4M/15M&#10;[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure></p>
<h3 id="u521B_u5EFAJava_u5458_u6587_u4EF6_u76EE_u5F55"><a href="#u521B_u5EFAJava_u5458_u6587_u4EF6_u76EE_u5F55" class="headerlink" title="创建Java员文件目录"></a>创建Java员文件目录</h3><p>根据上篇文章说的标准的目录结构，创建目录。比方说<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src&#10;  main&#10;    java</span><br></pre></td></tr></table></figure></p>
<p>java目录就是可以放具体的java源文件里。</p>
<h3 id="u521B_u5EFAjava_u6E90_u6587_u4EF6"><a href="#u521B_u5EFAjava_u6E90_u6587_u4EF6" class="headerlink" title="创建java源文件"></a>创建java源文件</h3><p>在java源文件目录（src/main/java）然后可以创建helloworld包，在包下创建HelloWorld源文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package helloworld;&#10;&#10;public class HelloWorld &#123;&#10;&#10;&#9;public static void main(String args[])&#123;&#10;&#10;&#9;&#9;System.out.println(&#34;Hello World, Maven&#34;);&#10;&#10;&#9;&#125;&#10;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>保存文件</p>
<h3 id="u6784_u5EFA_u5DE5_u7A0B"><a href="#u6784_u5EFA_u5DE5_u7A0B" class="headerlink" title="构建工程"></a>构建工程</h3><p>把java源文件，使用mvn package命令来实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure></p>
<p>这个命令会运行default生命周期，package是具体的阶段。执行的时候会编译java源文件，然后打包JAR文件。相关的编译结果会存在target目录中。<br>JAR生成的文件，也在target目录中，一般是<code>artifactId-version</code><br>上述工程，生成的包<code>hello-world-1.0.0.jar</code></p>
<p><a href="http://tutorials.jenkov.com/maven/your-first-maven-project.html" target="_blank" rel="external">http://tutorials.jenkov.com/maven/your-first-maven-project.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在这篇文章里，主要创建第一个maven工程，就是根据我们之前学到的基础信息，完成一个简单的实践。目标建立一个java工程，可以写java代码，然后打包成jar包。</p>
<h2 id="u5B89_u88C5Maven"><a href="#u5B89_u88C5Maven" class="headerlink" title="安装Maven"></a>安装Maven</h2><p>第一篇安装已经有相关的说明，请参照</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://luanburex.github.io/tags/java/"/>
    
      <category term="maven" scheme="http://luanburex.github.io/tags/maven/"/>
    
      <category term="安装部署" scheme="http://luanburex.github.io/tags/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/"/>
    
      <category term="maven" scheme="http://luanburex.github.io/categories/maven/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[maven入门（一）安装和基本概念]]></title>
    <link href="http://luanburex.github.io/2016/01/12/maven%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://luanburex.github.io/2016/01/12/maven入门（一）安装和基本概念/</id>
    <published>2016-01-12T03:21:50.000Z</published>
    <updated>2016-01-12T09:05:23.552Z</updated>
    <content type="html"><![CDATA[<h2 id="u4E3A_u4EC0_u4E48_u9700_u8981maven"><a href="#u4E3A_u4EC0_u4E48_u9700_u8981maven" class="headerlink" title="为什么需要maven"></a>为什么需要maven</h2><p>简单的说maven就是一个基于java的自动构建工具，之前有ant，那为什么要有maven呢。最简单的回答就是maven会更好。如果要问好在哪里，可能需要认真学习一下才会有比较深刻的认识了。<br>这里如果有人问自动构建是什么？用通俗简单的说，就是把你平时手工的生成源码，编译，打包，生成文档，部署等工作实现自动化，写个脚本就能搞定。这样不仅提高里编译测试甚至发布的效率，还降低了人工操作可能带来的错误。</p>
<a id="more"></a>
<h2 id="u5B89_u88C5maven"><a href="#u5B89_u88C5maven" class="headerlink" title="安装maven"></a>安装maven</h2><h3 id="u5728Windows_u4E0A_u5B89_u88C5maven"><a href="#u5728Windows_u4E0A_u5B89_u88C5maven" class="headerlink" title="在Windows上安装maven"></a>在Windows上安装maven</h3><ol>
<li>先装JDK1.6+，然后设置好环境变量</li>
<li>下载apache maven到本地，解压。可到<a href="http://maven.apache.org" target="_blank" rel="external">http://maven.apache.org</a> 去下载最新版本</li>
<li>配置环境变量：M2_HOME和PATH<br><img src="http://img.my.csdn.net/uploads/201209/03/1346660898_6437.gif" alt="配置M2_HOME"><br><img src="http://img.my.csdn.net/uploads/201209/03/1346661027_8957.gif" alt="配置PATH"></li>
<li>在命令行执行<code>mvn -v</code></li>
</ol>
<p><strong>NOTE：</strong>配置本地仓储<br>其实就是把仓储放到什么地方去，默认的那个地方并不好，比如，我想本地存到d:/maven_repo<br>在maven的目录的conf下打开settings.xml,把<br><code>&lt;localRepository&gt;d:/maven_repo&lt;/localRepository&gt;</code>注释去掉，改成你的地址即可</p>
<h3 id="Maven_u7684_u914D_u7F6E_u6587_u4EF6"><a href="#Maven_u7684_u914D_u7F6E_u6587_u4EF6" class="headerlink" title="Maven的配置文件"></a>Maven的配置文件</h3><p>Maven有两个配置文件。配置文件里的设置，对所有的pom文件都是有效的。比如，你可以配置：</p>
<p>本地仓库的路径；<br>当前的编译配置选项<br>等等<br>配置文件名为settings.xml，两个配置文件分别为：</p>
<ul>
<li>Maven安装目录中：$M2_HOME/conf/settings.xml</li>
<li>用户主目录中：${user.home}/.m2/settings.xml</li>
</ul>
<p>两个配置文件都是可选的。如果两个文件都存在，则用户目录下的配置会覆盖Maven安装目录中的配置。</p>
<p>关于Maven配置文件，参考<a href="http://maven.apache.org/settings.html" target="_blank" rel="external">Maven配置文档</a></p>
<h2 id="Maven_u7684_u6838_u5FC3_u6982_u5FF5"><a href="#Maven_u7684_u6838_u5FC3_u6982_u5FF5" class="headerlink" title="Maven的核心概念"></a>Maven的核心概念</h2><p>Maven的中心思想是POM文件（项目对象模型）。POM文件是以XML文件的形式表述项目的资源，如源码、测试代码、依赖（用到的外部Jar包）等。POM文件应该位于项目的根目录下。</p>
<p>用一张图来表达Maven的POM文件结构：<br><img src="http://ifeve.com/wp-content/uploads/2014/06/maven-overview-1.png" alt=""></p>
<h3 id="POM_u6587_u4EF6"><a href="#POM_u6587_u4EF6" class="headerlink" title="POM文件"></a>POM文件</h3><p>在执行maven命令的时候，默认会寻找当前目录下的pom文件，这个文件就定义里上面说的核心的资源信息。这个文件更像是一个说明文件，说明我们构建的什么，用到哪些资源。<br>每一个项目都有一个POM文件。POM文件即pom.xml，应该放在项目的根目录下。一个项目如果分为多个子项目，一般来讲，父项目有一个POM文件，每一个子项目都有一个POM文件。在这种结构下，既可以一步构建整个项目，也可以各个子项目分开构建。</p>
<h3 id="u6784_u5EFA_u751F_u547D_u5468_u671F_26gt_3B_u9636_u6BB5_26gt_3B_u76EE_u6807"><a href="#u6784_u5EFA_u751F_u547D_u5468_u671F_26gt_3B_u9636_u6BB5_26gt_3B_u76EE_u6807" class="headerlink" title="构建生命周期&gt;阶段&gt;目标"></a>构建生命周期&gt;阶段&gt;目标</h3><p>maven的构建过程是会要分解位 “构建生命周期&gt;阶段&gt;目标”。个构建周期由一系列的构建阶段组成，每一个构建阶段由一系列的目标组成。当你运行maven的命令的时候，需要说明“构建生命周期&gt;阶段&gt;目标”的名称。但是如果只是指明里一个生命周期，那么这个生命周期下的所有阶段都会执行。（只指明一个阶段也类似）。说白里就是把你的整个构建工程，按照这三个概念进行划分，方便分开或者整体的执行。</p>
<h3 id="u4F9D_u8D56_u548C_u4ED3_u5E93"><a href="#u4F9D_u8D56_u548C_u4ED3_u5E93" class="headerlink" title="依赖和仓库"></a>依赖和仓库</h3><p>仓储，说白里就是把你项目中依赖的各种jar包，找个地方存起来，你用的时候直接引用就行了。<br>比方说，你有20个工程，每个工程可能都用到spring-core-4.3.jar的包，那么原始的工作，就是所有的工程都有这么一个jar，而且比方说可能包可能还有其他依赖的包，这烦死了，管理起来太不方便了。<br>那么引入仓储和包的管理，你只要在配置文件中，说明我需要什么包，那么maven自动会从中央仓储（网上）下载你需要的包和这个包依赖的其他包，一起引入到你的项目中，这太方便了，对不对。<br>这里可能只要记住，你本地有一个仓储然后网上有个远程仓储，用的时候会根据依赖关系先在本地找，没有？那么就去网上下载。</p>
<h3 id="u63D2_u4EF6"><a href="#u63D2_u4EF6" class="headerlink" title="插件"></a>插件</h3><p>构建插件可以向构建阶段中增加额外的构建目标。最厉害的是，你不仅自己可以定义插件，还有很多人写里很多有用的插件，你可以用拿来主义的精神，拿来直接自己用。</p>
<h3 id="u914D_u7F6E_u6587_u4EF6"><a href="#u914D_u7F6E_u6587_u4EF6" class="headerlink" title="配置文件"></a>配置文件</h3><p>这个配置文件说的可不是pom.xml。简单说是你构建用到配置文件，通过配置文件的不同，你的构建过程或者其中的各种参数不同。</p>
<h2 id="Maven_u7684POM_u6587_u4EF6"><a href="#Maven_u7684POM_u6587_u4EF6" class="headerlink" title="Maven的POM文件"></a>Maven的POM文件</h2><p>下面就详细说明一下pom文件。下面是最简单的文件样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;project xmlns=&#8221;http://maven.apache.org/POM/4.0.0&#8243;&#10;xmlns:xsi=&#8221;http://www.w3.org/2001/XMLSchema-instance&#8221;&#10;xsi:schemaLocation=&#8221;http://maven.apache.org/POM/4.0.0&#10;http://maven.apache.org/xsd/maven-4.0.0.xsd&#8221;&#62;&#10;&#9;&#60;modelVersion&#62;4.0.0&#60;/modelVersion&#62;&#10;&#9;&#60;groupId&#62;com.ai&#60;/groupId&#62;&#10;&#9;&#60;artifactId&#62;java-agent&#60;/artifactId&#62;&#10;&#9;&#60;version&#62;1.0.0&#60;/version&#62;&#10;&#60;/project&#62;</span><br></pre></td></tr></table></figure></p>
<p>modelVersion: POM模型的版本。4.0.0对Maven 2和3都可用。<br>groupId: 一个组织或者项目（比如开源项目）的唯一ID。一般用包的根路径。<br>artifactId： 项目名称。<br>version: 版本。<br>这些参数，可以参照很多其他开源项目起名的规范，设定好名称。</p>
<h3 id="u7236pom"><a href="#u7236pom" class="headerlink" title="父pom"></a>父pom</h3><p>所有的Maven pom文件都继承自一个父pom。如果没有指定父pom，则该pom文件继承自根pom。可以让一个pom文件显式地继承另一个pom文件。这样，可以通过修改公共父pom文件的设置来修改所有子pom文件的设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;project xmlns=&#8221;http://maven.apache.org/POM/4.0.0&#8243;&#10;xmlns:xsi=&#8221;http://www.w3.org/2001/XMLSchema-instance&#8221;&#10;xsi:schemaLocation=&#8221;http://maven.apache.org/POM/4.0.0&#10;http://maven.apache.org/xsd/maven-4.0.0.xsd&#8221;&#62;&#10;&#60;modelVersion&#62;4.0.0&#60;/modelVersion&#62;&#10;&#10;&#60;parent&#62;&#10;&#9;&#60;groupId&#62;org.codehaus.mojo&#60;/groupId&#62;&#10;&#9;&#60;artifactId&#62;my-parent&#60;/artifactId&#62;&#10;&#9;&#60;version&#62;2.0&#60;/version&#62;&#10;&#9;&#60;relativePath&#62;../my-parent&#60;/relativePath&#62;&#10;&#60;/parent&#62;&#10;&#10;&#60;artifactId&#62;my-project&#60;/artifactId&#62;&#10;&#8230;&#10;&#60;/project&#62;</span><br></pre></td></tr></table></figure></p>
<h2 id="maven_u8FD0_u884C_u8D77_u6765"><a href="#maven_u8FD0_u884C_u8D77_u6765" class="headerlink" title="maven运行起来"></a>maven运行起来</h2><p>你可以先去安装maven，然后建立一个pom文件，把这个文件放到你工程的的根目录里，然后你就可以使用maven来运行构建了</p>
<p>命令：<code>mvn [将构建周期、阶段或目标]</code></p>
<p>比方说:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install</span><br></pre></td></tr></table></figure></p>
<p>这个命令讲会执行构建阶段install（该阶段是Default周期中的）。这个阶段编译项目成jar文件，然后放入本地仓储中。在执行这个阶段，会执行该阶段之前的所有阶段。</p>
<h2 id="Maven_u76EE_u5F55_u7ED3_u6784"><a href="#Maven_u76EE_u5F55_u7ED3_u6784" class="headerlink" title="Maven目录结构"></a>Maven目录结构</h2><p>Maven有一个标准目录结构，如果使用这种目录结构，就无需在pom文件中指定源代码、测试代码等目录。<br>具体目录结构，参照<a href="http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html" target="_blank" rel="external">Maven标准目录结构介绍</a><br>主要目录结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- src&#10;  - main&#10;    - java&#10;    - resources&#10;    - webapp&#10;  - test&#10;    - java&#10;    - resources&#10;- target</span><br></pre></td></tr></table></figure></p>
<p>src目录是源代码和测试代码的根目录。main目录是应用的源代码目录。test目录是测试代码的目录。main和test下的java目录，分别表示应用的java源代码和测试代码。<br>resources目录包含项目的资源文件，比如应用的国际化配置的属性文件等。<br>如果是一个web项目，则webapp目录为web项目的根目录，其中包含如WEB-INF等子目录。<br>target目录是由Maven创建的，其中包含编译后的类文件、jar文件等。当执行maven的clean目标后，target目录会被清空。</p>
<h2 id="u9879_u76EE_u4F9D_u8D56_u5173_u7CFB"><a href="#u9879_u76EE_u4F9D_u8D56_u5173_u7CFB" class="headerlink" title="项目依赖关系"></a>项目依赖关系</h2><p>项目使用jar包一般要保持最新状态，这个有点难度。而且jar包一般存在依赖关系，这个可能是递归依赖的。mvaen可以保存你需要的jar包，递归的下载相关的jar,确保版本都是正确的。你只需要在pom文件里指定依赖jar包的名称、版本号，Maven会自动下载并放到你的Maven本地仓库中。如果这些外部jar包依赖了其它的库，它们也会被下载到你的Maven本地仓库。</p>
<p>在pom文件中，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;project xmlns=&#34;http://maven.apache.org/POM/4.0.0&#34;&#10;         xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;&#10;         xsi:schemaLocation=&#34;http://maven.apache.org/POM/4.0.0&#10;   http://maven.apache.org/xsd/maven-4.0.0.xsd&#34;&#62;&#10;    &#60;modelVersion&#62;4.0.0&#60;/modelVersion&#62;&#10;&#10;    &#60;groupId&#62;com.jenkov.crawler&#60;/groupId&#62;&#10;    &#60;artifactId&#62;java-web-crawler&#60;/artifactId&#62;&#10;    &#60;version&#62;1.0.0&#60;/version&#62;&#10;    &#10;      &#60;dependencies&#62;&#10;&#10;        &#60;dependency&#62;&#10;          &#60;groupId&#62;org.jsoup&#60;/groupId&#62;&#10;          &#60;artifactId&#62;jsoup&#60;/artifactId&#62;&#10;          &#60;version&#62;1.7.1&#60;/version&#62;&#10;        &#60;/dependency&#62;&#10;&#10;        &#60;dependency&#62;&#10;          &#60;groupId&#62;junit&#60;/groupId&#62;&#10;          &#60;artifactId&#62;junit&#60;/artifactId&#62;&#10;          &#60;version&#62;4.8.1&#60;/version&#62;&#10;          &#60;scope&#62;test&#60;/scope&#62;&#10;        &#60;/dependency&#62;&#10;&#10;      &#60;/dependencies&#62;&#10;    &#10;&#10;    &#60;build&#62;&#10;    &#60;/build&#62;&#10;&#10;&#60;/project&#62;</span><br></pre></td></tr></table></figure></p>
<p>在dependencies属性下有两个dependency子属性，每一个dependency属性描述了一个外部依赖。这个可以根据自己的需求写多个依赖。</p>
<p>每一个依赖由groupId, artifactId和version来描述。如果你有印象，这和我们在pom文件的开头用来标识项目的方式是一样的。上面的示例表明，项目的依赖为 org.jsoup组织下的1.7.1版本的jsoup，以及junit组织下的4.8.1版本的junit。</p>
<h3 id="u5916_u90E8_u4F9D_u8D56"><a href="#u5916_u90E8_u4F9D_u8D56" class="headerlink" title="外部依赖"></a>外部依赖</h3><p>Maven的外部依赖指的是不在Maven的仓库（包括本地仓库、中央仓库和远程仓库）中的依赖（jar包）。它可能位于你本地硬盘的某个地方，比如web应用的lib目录下。这里的“外部”是对Maven仓库系统而言的，不仅仅是对项目而言的。大部分的外部依赖都是针对项目的，很少的外部依赖是针对仓库系统的（即不在仓库中）。</p>
<p>配置外部依赖的示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;dependency&#62;&#10;  &#60;groupId&#62;mydependency&#60;/groupId&#62;&#10;  &#60;artifactId&#62;mydependency&#60;/artifactId&#62;&#10;  &#60;scope&#62;system&#60;/scope&#62;&#10;  &#60;version&#62;1.0&#60;/version&#62;&#10;  &#60;systemPath&#62;$&#123;basedir&#125;\war\WEB-INF\lib\mydependency.jar&#60;/systemPath&#62;&#10;&#60;/dependency&#62;</span><br></pre></td></tr></table></figure></p>
<p>groupId和artifactId为依赖的名称，即API的名称。scope属性为system。systemPath属性为jar文件的路径。${basedir}为pom文件所在的目录，路径中的其它部分是相对于该目录而言的。</p>
<h2 id="Maven_u4ED3_u5E93"><a href="#Maven_u4ED3_u5E93" class="headerlink" title="Maven仓库"></a>Maven仓库</h2><p>Maven仓库就是存储jar包和一些元数据信息的目录。其中的元数据即pom文件，描述了该jar包属于哪个项目，以及jar包所需的外部依赖。该元数据信息使得Maven可以递归地下载所有的依赖，直到整个依赖树都下载完毕并放到你的本地仓库中。</p>
<p>Maven仓库的详细介绍参考Maven 仓库介绍，快速介绍如下：</p>
<p>Maven有三种类型的仓库：</p>
<p>本地仓库<br>中央仓库<br>远程仓库</p>
<p>Maven根据以上的顺序去仓库中搜索依赖。首先是本地仓库，然后是中央仓库，最后，如果pom文件中配置了远程仓库，则会去远程仓库中查找。</p>
<p>本地仓库在安装的时候已经说了配置方式，中央仓库是Maven社区提供，不需要额外配置。<br>远程仓库是位于web服务器上的一个仓库，Maven可以从该仓库下载依赖，就像从中央仓库下载依赖一样。远程仓库可以位于Internet上的任何地方，也可以是位于本地网络中。</p>
<p>远程仓库一般用于放置组织内部的项目，该项目由多个项目共享。比如，由多个内部项目共用的安全项目。该安全项目不能被外部访问，因此不能放在公开的中央仓库下，而应该放到内部的远程仓库中。</p>
<p>远程仓库中的依赖也会被Maven下载到本地仓库中。</p>
<p>可以在pom文件里配置远程仓库。将以下的xml片段放到属性之后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;repositories&#62;&#10;   &#60;repository&#62;&#10;       &#60;id&#62;jenkov.code&#60;/id&#62;&#10;       &#60;url&#62;http://maven.jenkov.com/maven2/lib&#60;/url&#62;&#10;   &#60;/repository&#62;&#10;&#60;/repositories&#62;</span><br></pre></td></tr></table></figure></p>
<h2 id="Maven_u7684_u6784_u5EFA_u751F_u547D_u5468_u671F_u3001_u9636_u6BB5_u548C_u76EE_u6807"><a href="#Maven_u7684_u6784_u5EFA_u751F_u547D_u5468_u671F_u3001_u9636_u6BB5_u548C_u76EE_u6807" class="headerlink" title="Maven的构建生命周期、阶段和目标"></a>Maven的构建生命周期、阶段和目标</h2><h3 id="u6784_u5EFA_u751F_u547D_u5468_u671F_uFF08Life_Cycle_uFF09"><a href="#u6784_u5EFA_u751F_u547D_u5468_u671F_uFF08Life_Cycle_uFF09" class="headerlink" title="构建生命周期（Life Cycle）"></a>构建生命周期（Life Cycle）</h3><p>Maven有三个内嵌的构建生命周期：</p>
<ul>
<li>default</li>
<li>clean</li>
<li>site</li>
</ul>
<p>default生命期关注的是项目的编译和打包。clean生命期关注的是从输出目录中删掉临时文件，包括自动生成的源文件、编译后的类文件，之前版本的jar文件等。site生命期关注的是为项目生成文档。实际上，site可以使用文档为项目生成一个完整的网站。</p>
<h3 id="u6784_u5EFA_u9636_u6BB5_uFF08Phase_uFF09"><a href="#u6784_u5EFA_u9636_u6BB5_uFF08Phase_uFF09" class="headerlink" title="构建阶段（Phase）"></a>构建阶段（Phase）</h3><p>default生命期更多的关注于构建代码。由于你不能直接执行default生命期，你需要执行其中一个构建阶段或者构建目标。default生命期包含了相当多的构建阶段和目标，这里不会所有都介绍。最常用的构建阶段有：</p>
<p>构建阶段           描述<br>validate           验证项目的正确性，以及所有必需的信息都是否都存在。同时也会确认项目的依赖是否都下载完毕。<br>compile            编译项目的源代码<br>test               选择合适的单元测试框架，对编译后的源码执行测试；这些测试不需要代码被打包或者部署。<br>package            将编译后的代码以可分配的形式打包，如Jar包。<br>install            将项目打包后安装到本地仓库，可以作为其它项目的本地依赖。<br>deploy             将最终的包复制到远程仓库，与其它开发者和项目共享。    </p>
<h3 id="u6784_u5EFA_u76EE_u6807_uFF08goal_uFF09"><a href="#u6784_u5EFA_u76EE_u6807_uFF08goal_uFF09" class="headerlink" title="构建目标（goal）"></a>构建目标（goal）</h3><p>构建目标是Maven构建过程中最细化的步骤。一个目标可以与一个或多个构建阶段绑定，也可以不绑定。如果一个目标没有与任何构建阶段绑定，你只能将该目标的名称作为参数传递给mvn命令来执行它。如果一个目标绑定到多个构建阶段，该目标在绑定的构建阶段执行的同时被执行</p>
<h2 id="Maven_u6784_u5EFA_u914D_u7F6E"><a href="#Maven_u6784_u5EFA_u914D_u7F6E" class="headerlink" title="Maven构建配置"></a>Maven构建配置</h2><p>相关构建配置，可以查询相关具体的<a href="http://maven.apache.org/pom.html#Profiles" target="_blank" rel="external">文档</a><br>其实只要pom文件中，在profiles里进行属性配置即可，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;project xmlns=&#34;http://maven.apache.org/POM/4.0.0&#34;&#10;         xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;&#10;         xsi:schemaLocation=&#34;http://maven.apache.org/POM/4.0.0&#10;   http://maven.apache.org/xsd/maven-4.0.0.xsd&#34;&#62;&#10;  &#60;modelVersion&#62;4.0.0&#60;/modelVersion&#62;&#10;&#10;  &#60;groupId&#62;com.jenkov.crawler&#60;/groupId&#62;&#10;  &#60;artifactId&#62;java-web-crawler&#60;/artifactId&#62;&#10;  &#60;version&#62;1.0.0&#60;/version&#62;&#10;&#10;  &#60;profiles&#62;&#10;      &#60;profile&#62;&#10;          &#60;id&#62;test&#60;/id&#62;&#10;          &#60;activation&#62;...&#60;/activation&#62;&#10;          &#60;build&#62;...&#60;/build&#62;&#10;          &#60;modules&#62;...&#60;/modules&#62;&#10;          &#60;repositories&#62;...&#60;/repositories&#62;&#10;          &#60;pluginRepositories&#62;...&#60;/pluginRepositories&#62;&#10;          &#60;dependencies&#62;...&#60;/dependencies&#62;&#10;          &#60;reporting&#62;...&#60;/reporting&#62;&#10;          &#60;dependencyManagement&#62;...&#60;/dependencyManagement&#62;&#10;          &#60;distributionManagement&#62;...&#60;/distributionManagement&#62;&#10;      &#60;/profile&#62;&#10;  &#60;/profiles&#62;&#10;&#10;&#60;/project&#62;</span><br></pre></td></tr></table></figure></p>
<p>还可以配置自定义的属性，然后在后面的配置中使用${}语法使用配置项目；<br>另外, activation属性可以根据条件设置不同的属性，可以参看apache maven的文档。可以通过命令mvn -P激活相应选项的属性集。<br>对于使用Maven3，我们可以有多个地方定义profile。定义的地方不同，它的作用范围也不同。</p>
<ol>
<li>针对于特定项目的profile配置我们可以定义在该项目的pom.xml中。</li>
<li>针对于特定用户的profile配置，我们可以在用户的settings.xml文件中定义profile。该文件在用户家目录下的“.m2”目录下。</li>
<li>全局的profile配置。全局的profile是定义在Maven安装目录下的“conf/settings.xml”文件中的。</li>
</ol>
<h2 id="Maven_u63D2_u4EF6"><a href="#Maven_u63D2_u4EF6" class="headerlink" title="Maven插件"></a>Maven插件</h2><p>使用Maven插件，可以向构建过程添加自定义的动作。创建一个简单的Java类，该类继承一个特殊的Maven类，然后为项目创建一个pom文件。该插件应该位于其项目下。</p>
<p>为了使本教程简短，关于开发插件的更多细节请参考<a href="http://maven.apache.org/plugin-developers/index.html" target="_blank" rel="external">Maven插件开发中心</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u4E3A_u4EC0_u4E48_u9700_u8981maven"><a href="#u4E3A_u4EC0_u4E48_u9700_u8981maven" class="headerlink" title="为什么需要maven"></a>为什么需要maven</h2><p>简单的说maven就是一个基于java的自动构建工具，之前有ant，那为什么要有maven呢。最简单的回答就是maven会更好。如果要问好在哪里，可能需要认真学习一下才会有比较深刻的认识了。<br>这里如果有人问自动构建是什么？用通俗简单的说，就是把你平时手工的生成源码，编译，打包，生成文档，部署等工作实现自动化，写个脚本就能搞定。这样不仅提高里编译测试甚至发布的效率，还降低了人工操作可能带来的错误。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://luanburex.github.io/tags/java/"/>
    
      <category term="maven" scheme="http://luanburex.github.io/tags/maven/"/>
    
      <category term="安装部署" scheme="http://luanburex.github.io/tags/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/"/>
    
      <category term="maven" scheme="http://luanburex.github.io/categories/maven/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[maven使用tomcat插件实现热部署]]></title>
    <link href="http://luanburex.github.io/2016/01/11/maven%E4%BD%BF%E7%94%A8tomcat%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E7%83%AD%E9%83%A8%E7%BD%B2/"/>
    <id>http://luanburex.github.io/2016/01/11/maven使用tomcat插件实现热部署/</id>
    <published>2016-01-11T02:24:27.000Z</published>
    <updated>2016-01-13T04:04:07.665Z</updated>
    <content type="html"><![CDATA[<p>通过maven的tomcat插件，实现热部署安装。</p>
<a id="more"></a>
<h2 id="u5B89_u88C5_u63D2_u4EF6_u5E76_u8FD0_u884C"><a href="#u5B89_u88C5_u63D2_u4EF6_u5E76_u8FD0_u884C" class="headerlink" title="安装插件并运行"></a>安装插件并运行</h2><p>首先要在pom.xml文件里，加入tomcat的插件说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;project&#62;&#10;  ...&#10;  &#60;build&#62;&#10;    ...&#10;    &#60;plugins&#62;&#10;      ...&#10;        &#60;plugin&#62;&#10;            &#60;groupId&#62;org.apache.tomcat.maven&#60;/groupId&#62;&#10;            &#60;artifactId&#62;tomcat6-maven-plugin&#60;/artifactId&#62;&#10;            &#60;version&#62;2.1&#60;/version&#62;&#10;            &#60;configuration&#62;&#10;                &#60;uriEncoding&#62;utf-8&#60;/uriEncoding&#62;&#10;&#9;&#9;&#9;        &#60;port&#62;8080&#60;/port&#62;&#10;                &#60;path&#62;/aiga&#60;/path&#62;&#10;            &#60;/configuration&#62;&#10;        &#60;/plugin&#62;&#10;      ...&#10;    &#60;/plugins&#62;&#10;    ...&#10;  &#60;/build&#62;&#10;  ...&#10;&#60;/project&#62;</span><br></pre></td></tr></table></figure></p>
<p>这种方式会使用嵌入的tomcat6。当然tomcat6-maven-plugin插件，还支持你部署到启动的本地或者远程的tomcat上，这种deploy的方式我们后面讲。</p>
<p>然后执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn tomcat:run</span><br></pre></td></tr></table></figure></p>
<p>就会自动启动一个tomcat服务了，你可以</p>
<p><strong>NOTE:</strong>可以写个批处理来完成清理，打包，部署启动tomcat<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /d %~dp0&#10;set MAVEN_BATCH_PAUSE=on&#10;mvn clean package -DdownloadSources=true tomcat:run</span><br></pre></td></tr></table></figure></p>
<h2 id="u8BA9_u70ED_u90E8_u7F72_u8C03_u8BD5_u8DD1_u8D77_u6765"><a href="#u8BA9_u70ED_u90E8_u7F72_u8C03_u8BD5_u8DD1_u8D77_u6765" class="headerlink" title="让热部署调试跑起来"></a>让热部署调试跑起来</h2><p>上面我们的方法并没有使用外部的tomcat而是使用嵌入的工程，那么是无法进行调试的。<strong>需要开始DEBUG模式</strong><br>最简单的开启DEBUG模式，就是你使用eclipse的Debug As，然后选择maven build，在goal里，输入tomcat:run<br>请参照下图：<br><img src="/2016/01/11/maven使用tomcat插件实现热部署/DebugAs.png" alt="DebugAs配置图" title="DebugAs配置图"></p>
<h3 id="u547D_u4EE4_u884C_u6A21_u5F0F"><a href="#u547D_u4EE4_u884C_u6A21_u5F0F" class="headerlink" title="命令行模式"></a>命令行模式</h3><p>还有一种方式就是在命令行执行Debug模式，首先做一个批处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /d %~dp0&#10;set MAVEN_BATCH_PAUSE=on&#10;set MAVEN_OPTS=-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,address=8787,suspend=n,server=y -Xms256m -Xmx512m -XX:MaxPermSize=128m&#10;mvn clean package -DdownloadSources=true tomcat:run</span><br></pre></td></tr></table></figure></p>
<p>然后使用eclipse的远程调试，如下图：<br><img src="/2016/01/11/maven使用tomcat插件实现热部署/RemoteDebug.png" alt="RemoteDebug配置图" title="RemoteDebug配置图"></p>
<p>##往已经存在的tomcat上部署</p>
<ol>
<li><p>pom文件的配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#12288;&#60;plugin&#62;&#10;  &#60;groupId&#62;org.apache.tomcat.maven&#60;/groupId&#62;&#10;  &#60;artifactId&#62;tomcat6-maven-plugin&#60;/artifactId&#62;&#10;  &#60;version&#62;2.0-beta-1&#60;/version&#62;&#10;&#10;  &#60;configuration&#62;&#10;    &#60;url&#62;http://localhost:8080/manager&#60;/url&#62;&#10;    &#60;server&#62;tomcat&#60;/server&#62;&#10;    &#60;username&#62;admin&#60;/username&#62; &#10;    &#60;password&#62;admin&#60;/password&#62;&#10;    &#60;path&#62;/aialm&#60;/path&#62;&#10;    &#60;contextReloadable&#62;true&#60;/contextReloadable&#62;&#10;  &#60;/configuration&#62;&#10;&#60;/plugin&#62;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置setting.xml(maven的),这个id需跟我们pom.xml配置的id一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;servers&#62;&#10;&#12288;&#12288;&#60;server&#62;&#10;       &#60;id&#62;tomcat&#60;/id&#62;&#10;       &#60;username&#62;admin&#60;/username&#62;&#10;       &#60;password&#62;admin&#60;/password&#62;&#10;    &#60;/server&#62;&#10; &#60;/servers&#62;</span><br></pre></td></tr></table></figure>
</li>
<li><p>settings.xml配置完后，就需给admin用户赋权了，这个在tomcat安装目录下的conf/tomcat-users.xml文件，赋权代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;role rolename=&#34;admin&#34;/&#62;    &#10;&#60;role rolename=&#34;admin-gui&#34;/&#62;    &#10;&#60;role rolename=&#34;manager&#34;/&#62;    &#10;&#60;role rolename=&#34;manager-script&#34;/&#62;    &#10;&#60;role rolename=&#34;manager-gui&#34;/&#62;    &#10;&#60;role rolename=&#34;manager-jmx&#34;/&#62;&#10;&#60;role rolename=&#34;manager-status&#34;/&#62;&#10;&#60;user username=&#34;admin&#34; password=&#34;admin&#34; roles=&#34;admin,manager,manager-gui,admin-gui,manager-script,manager-jmx,manager-status&#34;/&#62;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>4.执行命令<br>部署： clean tomcat6:deploy<br>重新部署： clean tomcat6:redeploy<br>清除部署： tomcat6:undeploy</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>通过maven的tomcat插件，实现热部署安装。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://luanburex.github.io/tags/java/"/>
    
      <category term="maven" scheme="http://luanburex.github.io/tags/maven/"/>
    
      <category term="安装部署" scheme="http://luanburex.github.io/tags/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/"/>
    
      <category term="maven" scheme="http://luanburex.github.io/categories/maven/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[maven使用本地JAR包]]></title>
    <link href="http://luanburex.github.io/2016/01/08/maven%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0JAR%E5%8C%85/"/>
    <id>http://luanburex.github.io/2016/01/08/maven使用本地JAR包/</id>
    <published>2016-01-08T07:34:00.000Z</published>
    <updated>2016-01-13T04:26:54.824Z</updated>
    <content type="html"><![CDATA[<p>有些项目使用的jar包在maven的中央库中不存在，只有本地有，比方说oracle的jdbc包，那么可以使用本地的jar包通过maven来管理编译生成。使用本地jar包大致有两种方式：</p>
<ol>
<li>一种就是使用system scope</li>
<li>把jar包安装到本地repository中<a id="more"></a>
</li>
</ol>
<h2 id="u4F7F_u7528system_scope_u7684_u65B9_u5F0F"><a href="#u4F7F_u7528system_scope_u7684_u65B9_u5F0F" class="headerlink" title="使用system scope的方式"></a>使用system scope的方式</h2><p>那么你的配置文件就可以这么写<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.ai<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>my-jar<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="title">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">systemPath</span>&gt;</span>$&#123;project.basedir&#125;/lib/my-jar.jar<span class="tag">&lt;/<span class="title">systemPath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>NOTE:</strong>这种方式在引入包的时候，不会去判断依赖关系，如果你的包有其他依赖的包，需要一一引入。或者可以使用resources将本地包打进jar-with-dependencies；<br>还有要注意的是system的scope相当于provided，意思是这个jar在编译的时候会使用，但是生成war的时候并不提供，是需要运行环境提供。**</p>
<h3 id="u6700_u7B80_u5355_u7684_u4F9D_u8D56_u548Cwar_u6253_u5305_u89E3_u51B3_u65B9_u6848"><a href="#u6700_u7B80_u5355_u7684_u4F9D_u8D56_u548Cwar_u6253_u5305_u89E3_u51B3_u65B9_u6848" class="headerlink" title="最简单的依赖和war打包解决方案"></a>最简单的依赖和war打包解决方案</h3><ol>
<li>依赖关系，尽量把所有需要的包都自己写上包把，一般中央库没有包而使用自己的很少</li>
<li>不打包到war包里，修改lib的目录到/src/main/webapp/WEB-INF/lib/，把jar包拷贝到这个目录下是最简单的解决方案。</li>
</ol>
<h3 id="u5176_u4ED6_u89E3_u51B3_u65B9_u6848"><a href="#u5176_u4ED6_u89E3_u51B3_u65B9_u6848" class="headerlink" title="其他解决方案"></a>其他解决方案</h3><ol>
<li><p>打War包也包含你本地的jar包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;plugin&#62;&#10;       &#60;groupId&#62;org.apache.maven.plugins&#60;/groupId&#62;&#10;       &#60;artifactId&#62;maven-war-plugin&#60;/artifactId&#62;&#10;            &#60;configuration&#62;&#10;                &#60;webResources&#62;&#10;                    &#60;resource&#62;&#10;                        &#60;directory&#62;$&#123;project.basedir&#125;/lib&#60;/directory&#62;&#10;                        &#60;targetPath&#62;WEB-INF/lib&#60;/targetPath&#62;&#10;                        &#60;filtering&#62;true&#60;/filtering&#62;&#10;                        &#60;includes&#62;&#10;                            &#60;include&#62;**/*.jar&#60;/include&#62;&#10;                        &#60;/includes&#62;&#10;                    &#60;/resource&#62;&#10;                &#60;/webResources&#62;&#10;            &#60;/configuration&#62;&#10; &#60;/plugin&#62;</span><br></pre></td></tr></table></figure>
</li>
<li><p>去处理依赖关系并会根据依赖打包</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">executions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">id</span>&gt;</span>make-assembly<span class="tag">&lt;/<span class="title">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="title">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">goals</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="title">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="title">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="title">descriptorRefs</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="title">descriptorRef</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="title">descriptorRefs</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="title">finalName</span>&gt;</span>xxx-jar-with-dependencies<span class="tag">&lt;/<span class="title">finalName</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="title">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">executions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="title">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">plugins</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">targetPath</span>&gt;</span>lib/<span class="tag">&lt;/<span class="title">targetPath</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">directory</span>&gt;</span>lib/<span class="tag">&lt;/<span class="title">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">includes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">include</span>&gt;</span>**/my-jar.jar<span class="tag">&lt;/<span class="title">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">includes</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="title">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><em>PS:</em>这些方法有点笨重，如果是web项目的，我推荐还是用最简单的解决方案。</p>
<h2 id="u5C06jar_u5305_u5B89_u88C5_u5230_u672C_u5730_u5E93_u4E2D"><a href="#u5C06jar_u5305_u5B89_u88C5_u5230_u672C_u5730_u5E93_u4E2D" class="headerlink" title="将jar包安装到本地库中"></a>将jar包安装到本地库中</h2><p>只是一条命令的事情：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install:install-file -Dfile=my-jar.jar -DgroupId=org.richard -DartifactId=my-jar -Dversion=1.0 -Dpackaging=jar</span><br></pre></td></tr></table></figure></p>
<p><strong>NOTE:</strong>有人还推荐使用in project repository<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;repository&#62;&#10;    &#60;id&#62;in-project&#60;/id&#62;&#10;    &#60;name&#62;In Project Repo&#60;/name&#62;&#10;    &#60;url&#62;file://$&#123;project.basedir&#125;/lib&#60;/url&#62;&#10;&#60;/repository&#62;&#10;&#10;&#60;dependency&#62;&#10;    &#60;groupId&#62;org.richard&#60;/groupId&#62;&#10;    &#60;artifactId&#62;my-jar&#60;/artifactId&#62;&#10;    &#60;version&#62;1.0&#60;/version&#62;&#10;&#60;/dependency&#62;</span><br></pre></td></tr></table></figure></p>
<p>这也是一种解决方案把。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>有些项目使用的jar包在maven的中央库中不存在，只有本地有，比方说oracle的jdbc包，那么可以使用本地的jar包通过maven来管理编译生成。使用本地jar包大致有两种方式：</p>
<ol>
<li>一种就是使用system scope</li>
<li>把jar包安装到本地repository中]]>
    
    </summary>
    
      <category term="java" scheme="http://luanburex.github.io/tags/java/"/>
    
      <category term="maven" scheme="http://luanburex.github.io/tags/maven/"/>
    
      <category term="安装部署" scheme="http://luanburex.github.io/tags/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/"/>
    
      <category term="maven" scheme="http://luanburex.github.io/categories/maven/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HEXO安装笔记]]></title>
    <link href="http://luanburex.github.io/2016/01/08/HEXO%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/"/>
    <id>http://luanburex.github.io/2016/01/08/HEXO安装笔记/</id>
    <published>2016-01-08T06:37:52.000Z</published>
    <updated>2016-01-12T09:08:24.527Z</updated>
    <content type="html"><![CDATA[<p>使用HEXO快速部署github的博客，至于什么是hexo ,github需要另行了解里。</p>
<h2 id="u51C6_u5907_u6761_u4EF6"><a href="#u51C6_u5907_u6761_u4EF6" class="headerlink" title="准备条件"></a>准备条件</h2><p>需要提前安装node 和 git</p>
<h2 id="u5B89_u88C5_u8FC7_u7A0B"><a href="#u5B89_u88C5_u8FC7_u7A0B" class="headerlink" title="安装过程"></a>安装过程</h2><p>最简单的安装步骤，如下的命令执行一遍<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g&#10;hexo init blog&#10;cd blog&#10;npm install&#10;hexo server</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="u914D_u7F6E_config-yml"><a href="#u914D_u7F6E_config-yml" class="headerlink" title="配置_config.yml"></a>配置_config.yml</h2><p>这里主要信息可以根据名称配置</p>
<h2 id="u542F_u52A8_u670D_u52A1"><a href="#u542F_u52A8_u670D_u52A1" class="headerlink" title="启动服务"></a>启动服务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<h2 id="u5F00_u59CB_u542F_u7A0B"><a href="#u5F00_u59CB_u542F_u7A0B" class="headerlink" title="开始启程"></a>开始启程</h2><p>新建一个blog:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [title]</span><br></pre></td></tr></table></figure></p>
<p>生成静态文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure></p>
<p>启动服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure></p>
<p><strong>NOTE：</strong>必要的时候需要清理生成文件需要执行<code>hexo clean</code></p>
<h2 id="u90E8_u7F72_u5230GitHub"><a href="#u90E8_u7F72_u5230GitHub" class="headerlink" title="部署到GitHub"></a>部署到GitHub</h2><p>先要安装对github部署的支持<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>
<p>要修改_config.yml，PS：这里要注意地址需要使用ssh格式的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Deployment&#10;## Docs: https://hexo.io/docs/deployment.html&#10;deploy: &#10;  type: git&#10;  repository: git@github.com:luanburex/luanburex.github.io.git&#10;  branch: master</span><br></pre></td></tr></table></figure></p>
<p>然后执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p>
<p><strong>NOTE:</strong>需要建立一个（luanburex.github.io）和自己名字一样的仓储</p>
<h2 id="u540E_u8BB0"><a href="#u540E_u8BB0" class="headerlink" title="后记"></a>后记</h2><h3 id="u4E0A_u4F20_u56FE_u7247"><a href="#u4E0A_u4F20_u56FE_u7247" class="headerlink" title="上传图片"></a>上传图片</h3><p>在_config.yml的配置文件里加入<code>post_asset_folder: true</code>，这样在新建文章的时候，会建立一个asserts目录，把图片放到这个目录下去。<br>然后在文章中直接使用即可</p>
<h3 id="u547D_u4EE4_u7B80_u5199"><a href="#u547D_u4EE4_u7B80_u5199" class="headerlink" title="命令简写"></a>命令简写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n == hexo new&#10;hexo g == hexo generate&#10;hexo s == hexo server&#10;hexo d == hexo deploy</span><br></pre></td></tr></table></figure>
<h3 id="u5B89_u88C5Maupassant_u4E3B_u9898"><a href="#u5B89_u88C5Maupassant_u4E3B_u9898" class="headerlink" title="安装Maupassant主题"></a>安装Maupassant主题</h3><p>在命令行执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant&#10;npm install hexo-renderer-sass --save&#10;npm install hexo-renderer-jade --save</span><br></pre></td></tr></table></figure></p>
<p>然后配置_config.yml文件, 将theme设置成maupassant<br><em>其他主题可以在官方网站上选择</em></p>
<p>最终看一下效果把<br><img src="/2016/01/08/HEXO安装笔记/最终效果图.png" alt="最终效果图" title="最终效果图"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>使用HEXO快速部署github的博客，至于什么是hexo ,github需要另行了解里。</p>
<h2 id="u51C6_u5907_u6761_u4EF6"><a href="#u51C6_u5907_u6761_u4EF6" class="headerlink" title="准备条件"></a>准备条件</h2><p>需要提前安装node 和 git</p>
<h2 id="u5B89_u88C5_u8FC7_u7A0B"><a href="#u5B89_u88C5_u8FC7_u7A0B" class="headerlink" title="安装过程"></a>安装过程</h2><p>最简单的安装步骤，如下的命令执行一遍<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g&#10;hexo init blog&#10;cd blog&#10;npm install&#10;hexo server</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="hexo" scheme="http://luanburex.github.io/tags/hexo/"/>
    
      <category term="markdown" scheme="http://luanburex.github.io/tags/markdown/"/>
    
      <category term="node" scheme="http://luanburex.github.io/tags/node/"/>
    
      <category term="安装部署" scheme="http://luanburex.github.io/tags/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://luanburex.github.io/2016/01/08/hello-world/"/>
    <id>http://luanburex.github.io/2016/01/08/hello-world/</id>
    <published>2016-01-08T06:24:25.680Z</published>
    <updated>2016-01-08T06:24:25.680Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start"><a href="#Quick_Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create_a_new_post"><a href="#Create_a_new_post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server"><a href="#Run_server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files"><a href="#Generate_static_files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites"><a href="#Deploy_to_remote_sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.]]>
    </summary>
    
  </entry>
  
</feed>
